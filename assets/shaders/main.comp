#version 460
#extension GL_EXT_scalar_block_layout : enable

#include "camera.glsl"

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, rgba8) uniform writeonly image2D image;

layout(push_constant, scalar) uniform PushConstants {
    uint width;
    uint height;
    uint timeMillis;
} pc;

const int MAX_STEPS = 200;
const float MAX_DISTANCE = 1000.0;
const float SAMPLE_DISTANCE = 0.02;

float sdSphere(vec3 p, float s) {
    return length(p) - s;
}

float sdBox(vec3 p, vec3 b) {
  vec3 q = abs(p) - b;
  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float scene(vec3 p) {
    // return sdSphere(p, 1.0);
    return sdBox(p, vec3(1.0));
}

float sampleDensity(vec3 p) {
    return 0.5;
}

vec3 raymarch(vec3 ro, vec3 rd) {
    float t = 0.0;
    float transmittance = 1.0;

    for (int i = 0; i < MAX_STEPS; ++i) {
        vec3 p = ro + rd * t;
        float d = scene(p);

        if (d > SAMPLE_DISTANCE) {
            t += d;
        } else {
            t += SAMPLE_DISTANCE;
            float density = sampleDensity(p);
            transmittance *= exp(-density * SAMPLE_DISTANCE);
        }

        if (transmittance < 0.01 || d > MAX_DISTANCE) {
            break;
        }
    }

    return vec3(1.0 - transmittance);
}

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

    if (coord.x >= pc.width || coord.y >= pc.height) {
        return;
    }

    vec2 uv = vec2(
        float(coord.x) / float(pc.width - 1),
        1.0 - float(coord.y) / float(pc.height - 1)
    );

    vec2 ndc = uv * 2.0 - 1.0;
    ndc.x *= float(pc.width) / float(pc.height);

    float r1 = sin(pc.timeMillis * 0.0005);
    float r2 = cos(pc.timeMillis * 0.0005);

    Camera camera;
    camera.position = vec3(r1 * 10.0, r1 * 10.0, r2 * 10.0);
    camera.rotation = cameraLookAt(camera.position, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));
    camera.fov = focalLengthToVerticalFov(35.0);

    float tanHalfFov = tan(camera.fov * 0.5);
    vec3 cameraDirection = normalize(vec3(ndc.x * tanHalfFov, ndc.y * tanHalfFov, 1.0));

    vec3 rayOrigin = camera.position;
    vec3 rayDirection = normalize(camera.rotation * cameraDirection);
    vec3 color = raymarch(rayOrigin, rayDirection);

    imageStore(image, coord, vec4(color, 1.0));
}
